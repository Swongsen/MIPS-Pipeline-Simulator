for(map<int, vector<string>>::iterator it = source_registers_inpipeline.begin(); it != source_registers_inpipeline.end(); it++){
  if(it->first < cycle){
    for(int i = 0; i < it->second.size(); i++){
      cout << "mems: " << memSource << " | ";
      if(memSource == it->second.at(i)){
        noHazards = false;
        cout << "HAZARDDDDDDDDD";
      }
      else{
        cout << it->second.at(i);
      }
    }
  }
}


// cout << "Destinations before current instruction: ";
// for(int i = 0; i < loadstore_destinations_before_currentInstruction.size(); i++){
//   cout << loadstore_destinations_before_currentInstruction.at(i) << " ";
// }
// cout << "\n";






if(i > 0){
  for(int w = i-1; w > 0; w--){

// For all the instructions above an instruction, i.e: if this is i = 1, or 2nd instruction, checks i=0 or 1st instruction for if destination registers are the same
// Check the first argument. If it is the same as an SW, store it in the source(0) memory waited on.
// and if it is a LW, store it in the destination(1) memory waited on.

// If the registers match
if(preissue_instructions_tokened[w].at(2) == preissue_instructions_tokened[i].at(2)){
  // If the instruction previous was an SW, the memory register is a source and is stored as such
    if(register_memorytype_waiting.count(preissue_instructions_tokened[w]) == 0){
      memory_registers_waited.insert(pair<string, int>(preissue_instructions_tokened[w], 0);
      memoryReady = false;
    }
    else if(memory_registers_waited.count(preissue_instructions_tokened[w]) > 0){
      memoryReady = false;
    }
  }
  // If the instruction previous was an LW, the memory register is a destination and is stored as such
  else if(preissue_instructions_tokened[w].at(1) == "LW"){
    if(memory_registers_waited[1].count(preissue_instructions_tokened[w]) == 0){
      memory_registers_waited.insert(pair<int, vector<string>>(1, vector<string>()));
      memory_registers_waited[1].push_back(preissue_instructions_tokened[i].at(2));
      memoryReady = false;
    }
    else if(memory_registers_waited[1].count(preissue_instructions_tokened[w]) > 0){
      memoryReady = false;
    }
  }
