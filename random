for(map<int, vector<string>>::iterator it = source_registers_inpipeline.begin(); it != source_registers_inpipeline.end(); it++){
  if(it->first < cycle){
    for(int i = 0; i < it->second.size(); i++){
      cout << "mems: " << memSource << " | ";
      if(memSource == it->second.at(i)){
        noHazards = false;
        cout << "HAZARDDDDDDDDD";
      }
      else{
        cout << it->second.at(i);
      }
    }
  }
}


// cout << "Destinations before current instruction: ";
// for(int i = 0; i < loadstore_destinations_before_currentInstruction.size(); i++){
//   cout << loadstore_destinations_before_currentInstruction.at(i) << " ";
// }
// cout << "\n";

// If the instruction up next is a LW/SW, check it for hazards.
if(preissue_instructions_tokened[i].at(1) == "SW" || preissue_instructions_tokened[i].at(1) == "LW"){
  memSource = memory_sourceString(preissue_instructions_tokened, i, memSource);
  possible_memory_instructions++;
  cout <<"yeo\n";
  // This checks if the source for this load or store word instruction is the destination of a previous register. hazard detected it if it is
  for(map<int, vector<string>>::iterator it = destination_registers_inpipeline.begin(); it != destination_registers_inpipeline.end(); it++){
    for(int i = 0; i < it->second.size(); i++){
      if(it->first <= cycle){
        if(memSource == it->second.at(i)){
          cout << "HAZARD:: \n";
          noHazards = false;
        }
      }
    }
  }
}


// If the instrction is not a load or store. Size 5 vector length means it is an immediate or normal instruction
if(preissue_instructions_tokened[i].size() == 5 && branch_stalled != true){
  cout << "garbage";
  // For the previous instructions, if the instruction's source registers are the previous instructions destination, then it is a raw hazard
  for(int k = i-1; k >= 0; k--){
    if(preissue_instructions_tokened[k].at(1) == "LW" || preissue_instructions_tokened[k].at(1) == "SW" && preissue_instructions_tokened[i].at(3) == preissue_instructions_tokened[k].at(2) || preissue_instructions_tokened[i].at(4) == preissue_instructions_tokened[k].at(2)){
      if(preissue_instructions_tokened[i].size() == 4){
        memoryReady = false;
      }
      cout << "falsey";
      noRaw = false;
    }
  }
  // if there is no hazard there, check if the instruction's destination register is any of the source registers of the previous
  if(noRaw == true){
    for(map<int, vector<string>>::iterator it = source_registers_inpipeline.begin(); it != source_registers_inpipeline.end(); it++){
      for(int j = 0; j < it->second.size(); j++){
        if(it->first <= cycle){
          if(preissue_instructions_tokened[i].at(3) == it->second.at(j) || preissue_instructions_tokened[i].at(4) == it->second.at(j)){
            cout << "TrueE";
            noRaw = false;
          }
        }
      }
    }
  }

}// end of not memory instruction checking for hazards





if(i > 0){
  for(int w = i-1; w > 0; w--){

// For all the instructions above an instruction, i.e: if this is i = 1, or 2nd instruction, checks i=0 or 1st instruction for if destination registers are the same
// Check the first argument. If it is the same as an SW, store it in the source(0) memory waited on.
// and if it is a LW, store it in the destination(1) memory waited on.

// If the registers match
if(preissue_instructions_tokened[w].at(2) == preissue_instructions_tokened[i].at(2)){
  // If the instruction previous was an SW, the memory register is a source and is stored as such
    if(register_memorytype_waiting.count(preissue_instructions_tokened[w]) == 0){
      memory_registers_waited.insert(pair<string, int>(preissue_instructions_tokened[w], 0);
      memoryReady = false;
    }
    else if(memory_registers_waited.count(preissue_instructions_tokened[w]) > 0){
      memoryReady = false;
    }
  }
  // If the instruction previous was an LW, the memory register is a destination and is stored as such
  else if(preissue_instructions_tokened[w].at(1) == "LW"){
    if(memory_registers_waited[1].count(preissue_instructions_tokened[w]) == 0){
      memory_registers_waited.insert(pair<int, vector<string>>(1, vector<string>()));
      memory_registers_waited[1].push_back(preissue_instructions_tokened[i].at(2));
      memoryReady = false;
    }
    else if(memory_registers_waited[1].count(preissue_instructions_tokened[w]) > 0){
      memoryReady = false;
    }
  }
